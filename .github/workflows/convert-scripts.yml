name: Convert Scripts

on:
  push:
    branches: [ main ]
    paths:
      - 'QuantumultX/*.js'
  pull_request:
    branches: [ main ]
    paths:
      - 'QuantumultX/*.js'
  workflow_dispatch:  # Allow manual triggering

# Add explicit permissions for the GITHUB_TOKEN
permissions:
  contents: write

jobs:
  convert:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
      
      - name: Create basic converter script
        run: |
          mkdir -p tools
          cat > tools/convert.js << 'EOF'
          const fs = require('fs');
          const path = require('path');

          function convertToSurge(content, inputFile) {
            // Extract filename for naming
            const filename = path.basename(inputFile, '.js');
            
            // Extract metadata from script if available
            let name = filename;
            let desc = 'Converted from QuantumultX';
            
            const nameMatch = content.match(/[\/\*\s]*?name\s*=\s*['"]*(.+?)['"]*[\n\r]/i);
            const descMatch = content.match(/[\/\*\s]*?desc\s*=\s*['"]*(.+?)['"]*[\n\r]/i);
            
            if (nameMatch && nameMatch[1]) {
              name = nameMatch[1].trim().replace(/['"]/g, '');
            }
            
            if (descMatch && descMatch[1]) {
              desc = descMatch[1].trim().replace(/['"]/g, '');
            }
            
            // Define the Surge module header
            let moduleContent = `#!name=${name}\n`;
            moduleContent += `#!desc=${desc}\n\n`;
            
            // Determine if this is a script or rewrite file
            const isScript = content.includes('$task.fetch') || 
                           content.includes('$done(') || 
                           content.includes('function') ||
                           !content.includes('url ');
            
            if (isScript) {
              // This is a script file
              // Convert the script content with API translation
              let scriptContent = content;
              
              // $task.fetch to $httpClient
              scriptContent = scriptContent.replace(/\$task\.fetch\s*\(\s*(\{[\s\S]*?\})\s*\)/g, (match, options) => {
                if (options.includes('"method": "POST"') || options.includes('"method":"POST"')) {
                  return `$httpClient.post(${options}`;
                } else {
                  return `$httpClient.get(${options}`;
                }
              });
              
              // Convert $prefs to $persistentStore
              scriptContent = scriptContent.replace(/\$prefs\.valueForKey\s*\(\s*["'](.*?)["']\s*\)/g, 
                (match, key) => `$persistentStore.read("${key}")`);
              scriptContent = scriptContent.replace(/\$prefs\.setValueForKey\s*\(\s*(.*?)\s*,\s*["'](.*?)["']\s*\)/g, 
                (match, value, key) => `$persistentStore.write(${value}, "${key}")`);
              
              // Convert $notify to $notification.post
              scriptContent = scriptContent.replace(/\$notify\s*\(\s*(.*?)\s*,\s*(.*?)\s*,\s*(.*?)(?:\s*,\s*(.*?))?\s*\)/g, 
                (match, title, subtitle, body, options) => {
                  return `$notification.post(${title}, ${subtitle}, ${body})`;
                }
              );
              
              // Create a module that references the script
              moduleContent += `[Script]\n`;
              moduleContent += `${name.replace(/\s+/g, '_')} = type=cron,cronexp=0 0 * * *,script-path=${filename}.js,timeout=60,wake-system=1\n`;
              
              return { module: moduleContent, script: scriptContent };
            } else {
              // This is a rewrite/rule file
              
              // Check for host settings
              if (content.includes('hostname =') || content.includes('hostname=')) {
                moduleContent += `[MITM]\n`;
                const hostnameMatch = content.match(/hostname\s*=\s*(.+?)(?:[\n\r]|$)/);
                if (hostnameMatch && hostnameMatch[1]) {
                  moduleContent += `hostname = ${hostnameMatch[1].trim()}\n\n`;
                }
              }
              
              // Convert rewrite rules
              let hasRules = false;
              
              // Look for reject rules
              const rejectRules = content.match(/url\s+reject(-.*?)?\s+([^\n]+)/g);
              if (rejectRules && rejectRules.length > 0) {
                hasRules = true;
                moduleContent += `[URL Rewrite]\n`;
                rejectRules.forEach(rule => {
                  // Extract the URL pattern
                  const urlPattern = rule.replace(/url\s+reject(?:-.*?)?\s+/, '').trim();
                  moduleContent += `${urlPattern} - reject\n`;
                });
                moduleContent += '\n';
              }
              
              // Look for redirect rules
              const redirectRules = content.match(/url\s+30[27]\s+([^\n]+)\s+([^\n]+)/g);
              if (redirectRules && redirectRules.length > 0) {
                if (!hasRules) {
                  moduleContent += `[URL Rewrite]\n`;
                  hasRules = true;
                }
                redirectRules.forEach(rule => {
                  // Extract from and to URLs
                  const parts = rule.replace(/url\s+30[27]\s+/, '').trim().split(/\s+/);
                  if (parts.length >= 2) {
                    moduleContent += `${parts[0]} ${parts[1]} [302]\n`;
                  }
                });
                moduleContent += '\n';
              }
              
              // Look for response body rules
              const bodyRules = content.match(/url\s+response-body\s+([^\n]+)\s+([^\n]+)/g);
              if (bodyRules && bodyRules.length > 0) {
                moduleContent += `[Script]\n`;
                bodyRules.forEach((rule, index) => {
                  // Extract patterns and replacement
                  const parts = rule.replace(/url\s+response-body\s+/, '').trim().split(/\s+/);
                  if (parts.length >= 2) {
                    const scriptName = `body_replace_${index}`;
                    moduleContent += `${scriptName} = type=http-response,pattern=${parts[0]},requires-body=1,script-path=${filename}_${scriptName}.js\n`;
                    
                    // Create a simple replacement script
                    const bodyScript = `
                    var body = $response.body;
                    body = body.replace(/${parts[0]}/g, '${parts[1]}');
                    $done({body});
                    `;
                    
                    // Write the replacement script
                    fs.writeFileSync(path.join(path.dirname(inputFile), '..', 'Surge', `${filename}_${scriptName}.js`), bodyScript);
                  }
                });
                moduleContent += '\n';
              }
              
              return { module: moduleContent, script: null };
            }
          }

          function convertToLoon(content, inputFile) {
            // Extract filename for naming
            const filename = path.basename(inputFile, '.js');
            
            // Extract metadata from script if available
            let name = filename;
            let desc = 'Converted from QuantumultX';
            
            const nameMatch = content.match(/[\/\*\s]*?name\s*=\s*['"]*(.+?)['"]*[\n\r]/i);
            const descMatch = content.match(/[\/\*\s]*?desc\s*=\s*['"]*(.+?)['"]*[\n\r]/i);
            
            if (nameMatch && nameMatch[1]) {
              name = nameMatch[1].trim().replace(/['"]/g, '');
            }
            
            if (descMatch && descMatch[1]) {
              desc = descMatch[1].trim().replace(/['"]/g, '');
            }
            
            // Define the Loon plugin header
            let pluginContent = `#!name = ${name}\n`;
            pluginContent += `#!desc = ${desc}\n`;
            pluginContent += `#!author = Converted\n`;
            pluginContent += `#!icon = \n\n`;
            
            // Determine if this is a script or rewrite file
            const isScript = content.includes('$task.fetch') || 
                           content.includes('$done(') || 
                           content.includes('function') ||
                           !content.includes('url ');
            
            if (isScript) {
              // This is a script file
              // Convert the script content with API translation
              let scriptContent = content;
              
              // $task.fetch to $http
              scriptContent = scriptContent.replace(/\$task\.fetch\s*\(\s*(\{[\s\S]*?\})\s*\)/g, (match, options) => {
                if (options.includes('"method": "POST"') || options.includes('"method":"POST"')) {
                  return `$http.post(${options}`;
                } else {
                  return `$http.get(${options}`;
                }
              });
              
              // Convert $prefs to $storage
              scriptContent = scriptContent.replace(/\$prefs\.valueForKey\s*\(\s*["'](.*?)["']\s*\)/g, 
                (match, key) => `$persistentStore.read("${key}")`);
              scriptContent = scriptContent.replace(/\$prefs\.setValueForKey\s*\(\s*(.*?)\s*,\s*["'](.*?)["']\s*\)/g, 
                (match, value, key) => `$persistentStore.write(${value}, "${key}")`);
              
              // Convert $notify to $notification
              scriptContent = scriptContent.replace(/\$notify\s*\(\s*(.*?)\s*,\s*(.*?)\s*,\s*(.*?)(?:\s*,\s*(.*?))?\s*\)/g, 
                (match, title, subtitle, body, options) => {
                  return `$notification.post(${title}, ${subtitle}, ${body})`;
                }
              );
              
              // Create a plugin that references the script
              pluginContent += `[Script]\n`;
              pluginContent += `cron "${name}" script-path=${filename}.js,tag=${name.replace(/\s+/g, '_')},cronexp=0 0 * * *\n`;
              
              return { plugin: pluginContent, script: scriptContent };
            } else {
              // This is a rewrite/rule file
              
              // Check for host settings
              if (content.includes('hostname =') || content.includes('hostname=')) {
                pluginContent += `[MITM]\n`;
                const hostnameMatch = content.match(/hostname\s*=\s*(.+?)(?:[\n\r]|$)/);
                if (hostnameMatch && hostnameMatch[1]) {
                  pluginContent += `hostname = ${hostnameMatch[1].trim()}\n\n`;
                }
              }
              
              // Convert rewrite rules
              let hasRules = false;
              
              // Look for reject rules
              const rejectRules = content.match(/url\s+reject(-.*?)?\s+([^\n]+)/g);
              if (rejectRules && rejectRules.length > 0) {
                hasRules = true;
                pluginContent += `[Rewrite]\n`;
                rejectRules.forEach(rule => {
                  // Extract the URL pattern
                  const urlPattern = rule.replace(/url\s+reject(?:-.*?)?\s+/, '').trim();
                  pluginContent += `${urlPattern} reject\n`;
                });
                pluginContent += '\n';
              }
              
              // Look for redirect rules
              const redirectRules = content.match(/url\s+30[27]\s+([^\n]+)\s+([^\n]+)/g);
              if (redirectRules && redirectRules.length > 0) {
                if (!hasRules) {
                  pluginContent += `[Rewrite]\n`;
                  hasRules = true;
                }
                redirectRules.forEach(rule => {
                  // Extract from and to URLs
                  const parts = rule.replace(/url\s+30[27]\s+/, '').trim().split(/\s+/);
                  if (parts.length >= 2) {
                    pluginContent += `${parts[0]} 302 ${parts[1]}\n`;
                  }
                });
                pluginContent += '\n';
              }
              
              // Look for response body rules
              const bodyRules = content.match(/url\s+response-body\s+([^\n]+)\s+([^\n]+)/g);
              if (bodyRules && bodyRules.length > 0) {
                pluginContent += `[Script]\n`;
                bodyRules.forEach((rule, index) => {
                  // Extract patterns and replacement
                  const parts = rule.replace(/url\s+response-body\s+/, '').trim().split(/\s+/);
                  if (parts.length >= 2) {
                    const scriptName = `body_replace_${index}`;
                    pluginContent += `http-response ${parts[0]} script-path=${filename}_${scriptName}.js,requires-body=true,tag=${scriptName}\n`;
                    
                    // Create a simple replacement script
                    const bodyScript = `
                    var body = $response.body;
                    body = body.replace(/${parts[0]}/g, '${parts[1]}');
                    $done({body});
                    `;
                    
                    // Write the replacement script
                    fs.writeFileSync(path.join(path.dirname(inputFile), '..', 'Loon', `${filename}_${scriptName}.js`), bodyScript);
                  }
                });
                pluginContent += '\n';
              }
              
              return { plugin: pluginContent, script: null };
            }
          }

          // Main function
          function main() {
            const args = process.argv.slice(2);
            const inputArg = args.indexOf('--input');
            const outputDir = args.indexOf('--output-dir');
            const targetArg = args.indexOf('--target');
            
            if (inputArg === -1 || outputDir === -1 || targetArg === -1) {
              console.error('Usage: node convert.js --input <inputFile> --output-dir <outputDir> --target <surge|loon>');
              process.exit(1);
            }
            
            const inputFile = args[inputArg + 1];
            const outputDirectory = args[outputDir + 1];
            const target = args[targetArg + 1];
            
            if (!inputFile || !outputDirectory || !target) {
              console.error('Usage: node convert.js --input <inputFile> --output-dir <outputDir> --target <surge|loon>');
              process.exit(1);
            }
            
            try {
              const content = fs.readFileSync(inputFile, 'utf8');
              const filename = path.basename(inputFile, '.js');
              
              // Ensure output directory exists
              if (!fs.existsSync(outputDirectory)) {
                fs.mkdirSync(outputDirectory, { recursive: true });
              }
              
              if (target.toLowerCase() === 'surge') {
                const { module, script } = convertToSurge(content, inputFile);
                
                // Write the module file
                fs.writeFileSync(path.join(outputDirectory, `${filename}.sgmodule`), module);
                
                // If script content exists, write it too
                if (script) {
                  fs.writeFileSync(path.join(outputDirectory, `${filename}.js`), script);
                }
                
                console.log(`Successfully converted ${inputFile} to Surge format in ${outputDirectory}`);
              } else if (target.toLowerCase() === 'loon') {
                const { plugin, script } = convertToLoon(content, inputFile);
                
                // Write the plugin file
                fs.writeFileSync(path.join(outputDirectory, `${filename}.plugin`), plugin);
                
                // If script content exists, write it too
                if (script) {
                  fs.writeFileSync(path.join(outputDirectory, `${filename}.js`), script);
                }
                
                console.log(`Successfully converted ${inputFile} to Loon format in ${outputDirectory}`);
              } else {
                console.error(`Unsupported target: ${target}. Use 'surge' or 'loon'.`);
                process.exit(1);
              }
            } catch (error) {
              console.error(`Error: ${error.message}`);
              process.exit(1);
            }
          }

          main();
          EOF
      
      - name: Create output directories
        run: |
          mkdir -p Surge
          mkdir -p Loon
      
      - name: Convert QuantumultX scripts to Surge
        run: |
          for file in QuantumultX/*.js; do
            echo "Converting $(basename "$file") to Surge format..."
            node tools/convert.js --input "$file" --output-dir "Surge" --target surge
          done
      
      - name: Convert QuantumultX scripts to Loon
        run: |
          for file in QuantumultX/*.js; do
            echo "Converting $(basename "$file") to Loon format..."
            node tools/convert.js --input "$file" --output-dir "Loon" --target loon
          done
      
      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Add the converted files
          git add Surge/ Loon/
          
          # Commit if there are changes
          git diff-index --quiet HEAD || git commit -m "Auto convert scripts to Surge and Loon formats"
          
          # Set remote URL with token for authentication
          git remote set-url origin https://x-access-token:${{ github.token }}@github.com/${{ github.repository }}
          
          # Push 
          git push
