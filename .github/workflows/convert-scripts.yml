name: Convert Scripts

on:
  push:
    branches: [ main ]
    paths:
      - 'QuantumultX/*.js'
  pull_request:
    branches: [ main ]
    paths:
      - 'QuantumultX/*.js'
  workflow_dispatch:  # Allow manual triggering

# Add explicit permissions for the GITHUB_TOKEN
permissions:
  contents: write

jobs:
  convert:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
      
      - name: Create simplified converter script
        run: |
          mkdir -p tools
          cat > tools/convert.js << 'EOF'
          const fs = require('fs');
          const path = require('path');

          // Main function
          function main() {
            try {
              const args = process.argv.slice(2);
              const inputArg = args.indexOf('--input');
              const outputArg = args.indexOf('--output');
              const targetArg = args.indexOf('--target');
              
              if (inputArg === -1 || outputArg === -1 || targetArg === -1) {
                console.error('Missing required arguments');
                process.exit(1);
              }
              
              const inputFile = args[inputArg + 1];
              const outputFile = args[outputArg + 1];
              const target = args[targetArg + 1];
              
              if (!inputFile || !outputFile || !target) {
                console.error('Invalid arguments');
                process.exit(1);
              }
              
              console.log(`Processing ${inputFile} to ${outputFile} for ${target}`);
              
              // Read the input file
              const content = fs.readFileSync(inputFile, 'utf8');
              
              // Extract name and desc if available
              let name = path.basename(inputFile, '.js');
              let desc = "Converted from QuantumultX";
              
              const nameMatch = content.match(/name\s*=\s*['"]*([^'"]+)['"]*[\s,\n\r]/i);
              const descMatch = content.match(/desc\s*=\s*['"]*([^'"]+)['"]*[\s,\n\r]/i);
              
              if (nameMatch && nameMatch[1]) name = nameMatch[1].trim();
              if (descMatch && descMatch[1]) desc = descMatch[1].trim();
              
              // Convert based on target
              let outputContent = '';
              
              if (target === 'surge') {
                // Create Surge .sgmodule format
                outputContent = `#!name=${name}\n`;
                outputContent += `#!desc=${desc}\n\n`;
                
                // Add Script section if it appears to be a script
                if (content.includes('$task.fetch') || content.includes('$done(') || content.includes('function')) {
                  // Create separate js file for script
                  const scriptFile = outputFile.replace('.sgmodule', '.js');
                  let scriptContent = content;
                  
                  // Do API translations for script
                  scriptContent = scriptContent
                    .replace(/\$task\.fetch/g, '$httpClient.get')
                    .replace(/\$prefs\.valueForKey/g, '$persistentStore.read')
                    .replace(/\$prefs\.setValueForKey/g, '$persistentStore.write')
                    .replace(/\$notify/g, '$notification.post');
                  
                  fs.writeFileSync(scriptFile, scriptContent);
                  
                  // Add script reference to the module
                  outputContent += `[Script]\n`;
                  outputContent += `${name.replace(/\s+/g, '_')} = type=cron,cronexp=0 0 * * *,script-path=${path.basename(scriptFile)},timeout=60,wake-system=1\n\n`;
                } 
                
                // Check for rewrite rules
                if (content.includes('url ')) {
                  // Extract MITM hosts
                  if (content.includes('hostname =') || content.includes('hostname=')) {
                    outputContent += `[MITM]\n`;
                    const hostnameMatch = content.match(/hostname\s*=\s*(.+?)(?:[\n\r]|$)/);
                    if (hostnameMatch && hostnameMatch[1]) {
                      outputContent += `hostname = ${hostnameMatch[1].trim()}\n\n`;
                    }
                  }
                  
                  // Simple URL rewrite section
                  outputContent += `[URL Rewrite]\n`;
                  const urlLines = content.match(/[^\n]*url\s+[^\n]+/g) || [];
                  urlLines.forEach(line => {
                    if (line.includes('reject')) {
                      // Convert reject rules
                      const urlMatch = line.match(/([^\s]+)\s+url\s+reject/);
                      if (urlMatch && urlMatch[1]) {
                        outputContent += `${urlMatch[1]} - reject\n`;
                      }
                    } else if (line.includes('302') || line.includes('307')) {
                      // Convert redirect rules
                      const parts = line.split(/\s+url\s+30[27]\s+/);
                      if (parts.length === 2) {
                        outputContent += `${parts[0]} ${parts[1]} [302]\n`;
                      }
                    }
                  });
                }
              } else if (target === 'loon') {
                // Create Loon .plugin format
                outputContent = `#!name = ${name}\n`;
                outputContent += `#!desc = ${desc}\n`;
                outputContent += `#!author = Converted\n`;
                outputContent += `#!icon = \n\n`;
                
                // Add Script section if it appears to be a script
                if (content.includes('$task.fetch') || content.includes('$done(') || content.includes('function')) {
                  // Create separate js file for script
                  const scriptFile = outputFile.replace('.plugin', '.js');
                  let scriptContent = content;
                  
                  // Do API translations for script
                  scriptContent = scriptContent
                    .replace(/\$task\.fetch/g, '$http.get')
                    .replace(/\$prefs\.valueForKey/g, '$persistentStore.read')
                    .replace(/\$prefs\.setValueForKey/g, '$persistentStore.write')
                    .replace(/\$notify/g, '$notification.post');
                  
                  fs.writeFileSync(scriptFile, scriptContent);
                  
                  // Add script reference to the plugin
                  outputContent += `[Script]\n`;
                  outputContent += `cron "${name}" script-path=${path.basename(scriptFile)},tag=${name.replace(/\s+/g, '_')},cronexp=0 0 * * *\n\n`;
                }
                
                // Check for rewrite rules
                if (content.includes('url ')) {
                  // Extract MITM hosts
                  if (content.includes('hostname =') || content.includes('hostname=')) {
                    outputContent += `[MITM]\n`;
                    const hostnameMatch = content.match(/hostname\s*=\s*(.+?)(?:[\n\r]|$)/);
                    if (hostnameMatch && hostnameMatch[1]) {
                      outputContent += `hostname = ${hostnameMatch[1].trim()}\n\n`;
                    }
                  }
                  
                  // Simple Rewrite section
                  outputContent += `[Rewrite]\n`;
                  const urlLines = content.match(/[^\n]*url\s+[^\n]+/g) || [];
                  urlLines.forEach(line => {
                    if (line.includes('reject')) {
                      // Convert reject rules
                      const urlMatch = line.match(/([^\s]+)\s+url\s+reject/);
                      if (urlMatch && urlMatch[1]) {
                        outputContent += `${urlMatch[1]} reject\n`;
                      }
                    } else if (line.includes('302') || line.includes('307')) {
                      // Convert redirect rules
                      const parts = line.split(/\s+url\s+30[27]\s+/);
                      if (parts.length === 2) {
                        outputContent += `${parts[0]} 302 ${parts[1]}\n`;
                      }
                    }
                  });
                }
              }
              
              // If all else fails, include the original content as a comment
              if (!outputContent.includes('[Script]') && !outputContent.includes('[Rewrite]') && !outputContent.includes('[URL Rewrite]')) {
                outputContent += `\n/* Original content: */\n\n`;
                outputContent += content;
              }
              
              // Write output file
              fs.writeFileSync(outputFile, outputContent);
              console.log(`Conversion successful: ${outputFile}`);
            } catch (error) {
              console.error(`Error: ${error.message}`);
              process.exit(1);
            }
          }

          main();
          EOF
      
      - name: Create output directories
        run: |
          mkdir -p Surge
          mkdir -p Loon
      
      - name: Convert QuantumultX scripts to Surge
        run: |
          for file in QuantumultX/*.js; do
            filename=$(basename "$file" .js)
            echo "Converting $filename to Surge format..."
            node tools/direct-convert.js --input "$file" --output "Surge/${filename}.sgmodule" --target surge
          done
      
      - name: Convert QuantumultX scripts to Loon
        run: |
          for file in QuantumultX/*.js; do
            filename=$(basename "$file" .js)
            echo "Converting $filename to Loon format..."
            node tools/direct-convert.js --input "$file" --output "Loon/${filename}.plugin" --target loon
          done
      
      - name: Create output directories
        run: |
          mkdir -p Surge
          mkdir -p Loon
      
      - name: Convert QuantumultX scripts to Surge
        run: |
          for file in QuantumultX/*.js; do
            echo "Converting $(basename "$file") to Surge format..."
            node tools/convert.js --input "$file" --output-dir "Surge" --target surge
          done
      
      - name: Convert QuantumultX scripts to Loon
        run: |
          for file in QuantumultX/*.js; do
            echo "Converting $(basename "$file") to Loon format..."
            node tools/convert.js --input "$file" --output-dir "Loon" --target loon
          done
      
      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Add the converted files
          git add Surge/ Loon/
          
          # Commit if there are changes
          git diff-index --quiet HEAD || git commit -m "Auto convert scripts to Surge and Loon formats"
          
          # Set remote URL with token for authentication
          git remote set-url origin https://x-access-token:${{ github.token }}@github.com/${{ github.repository }}
          
          # Push 
          git push
