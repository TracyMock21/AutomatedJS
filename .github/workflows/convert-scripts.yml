name: Convert Scripts

on:
  push:
    branches: [ main ]
    paths:
      - 'QuantumultX/*.js'
  pull_request:
    branches: [ main ]
    paths:
      - 'QuantumultX/*.js'
  workflow_dispatch:  # Allow manual triggering

jobs:
  convert:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
      
      - name: Create custom converter script
        run: |
          mkdir -p tools
          cat > tools/convert.js << 'EOF'
          const fs = require('fs');
          const path = require('path');

          function convertToSurge(content) {
            let newContent = content;
            
            // Extract metadata from QuantumultX script
            let name = 'Converted Script';
            let desc = 'Converted from QuantumultX';
            
            const nameMatch = content.match(/[\s\S]*?name\s*=\s*(.+?)[\n\r]/i);
            const descMatch = content.match(/[\s\S]*?desc\s*=\s*(.+?)[\n\r]/i);
            
            if (nameMatch && nameMatch[1]) {
              name = nameMatch[1].trim();
            }
            
            if (descMatch && descMatch[1]) {
              desc = descMatch[1].trim();
            }
            
            // Add Surge-specific headers
            newContent = `#!name=${name}\n#!desc=${desc}\n\n` + newContent;
            
            // Convert QuantumultX API calls to Surge equivalents
            // $task.fetch() to $httpClient.get()/post()
            newContent = newContent.replace(/\$task\.fetch\s*\(\s*(\{[\s\S]*?\})\s*\)/g, (match, options) => {
              if (options.includes('"method": "POST"') || options.includes('"method":"POST"')) {
                return `$httpClient.post(${options}`;
              } else {
                return `$httpClient.get(${options}`;
              }
            });
            
            // Convert the callback structure
            newContent = newContent.replace(/\.then\s*\(\s*response\s*=>\s*\{([\s\S]*?)\$done\s*\(\s*(\{[\s\S]*?\})\s*\)/g, 
              (match, innerCode, doneObj) => {
                return `.then(function(response) {${innerCode}$done(${doneObj})`;
              }
            );
            
            // Convert $prefs to $persistentStore
            newContent = newContent.replace(/\$prefs\.valueForKey\s*\(\s*["'](.*?)["']\s*\)/g, 
              (match, key) => `$persistentStore.read("${key}")`);
            newContent = newContent.replace(/\$prefs\.setValueForKey\s*\(\s*(.*?)\s*,\s*["'](.*?)["']\s*\)/g, 
              (match, value, key) => `$persistentStore.write(${value}, "${key}")`);
            
            // Convert $notify to $notification.post
            newContent = newContent.replace(/\$notify\s*\(\s*(.*?)\s*,\s*(.*?)\s*,\s*(.*?)(?:\s*,\s*(.*?))?\s*\)/g, 
              (match, title, subtitle, body, options) => {
                if (options) {
                  // Handle the options parameter if needed
                  return `$notification.post(${title}, ${subtitle}, ${body})`;
                } else {
                  return `$notification.post(${title}, ${subtitle}, ${body})`;
                }
              }
            );
            
            return newContent;
          }

          function convertToLoon(content) {
            let newContent = content;
            
            // Extract metadata from QuantumultX script
            let name = 'Converted Script';
            let desc = 'Converted from QuantumultX';
            
            const nameMatch = content.match(/[\s\S]*?name\s*=\s*(.+?)[\n\r]/i);
            const descMatch = content.match(/[\s\S]*?desc\s*=\s*(.+?)[\n\r]/i);
            
            if (nameMatch && nameMatch[1]) {
              name = nameMatch[1].trim();
            }
            
            if (descMatch && descMatch[1]) {
              desc = descMatch[1].trim();
            }
            
            // Add Loon-specific headers
            newContent = `#!name = ${name}\n#!desc = ${desc}\n#!openUrl = \n#!author = Converted\n#!homepage = \n#!icon = \n\n` + newContent;
            
            // Convert QuantumultX API calls to Loon equivalents
            // $task.fetch() to $http.get()/post()
            newContent = newContent.replace(/\$task\.fetch\s*\(\s*(\{[\s\S]*?\})\s*\)/g, (match, options) => {
              if (options.includes('"method": "POST"') || options.includes('"method":"POST"')) {
                return `$http.post(${options}`;
              } else {
                return `$http.get(${options}`;
              }
            });
            
            // Convert the callback structure
            newContent = newContent.replace(/\.then\s*\(\s*response\s*=>\s*\{([\s\S]*?)\$done\s*\(\s*(\{[\s\S]*?\})\s*\)/g, 
              (match, innerCode, doneObj) => {
                return `, function(response) {${innerCode}$done(${doneObj})`;
              }
            );
            
            // Convert $prefs to $persistentStore
            newContent = newContent.replace(/\$prefs\.valueForKey\s*\(\s*["'](.*?)["']\s*\)/g, 
              (match, key) => `$storage.read("${key}")`);
            newContent = newContent.replace(/\$prefs\.setValueForKey\s*\(\s*(.*?)\s*,\s*["'](.*?)["']\s*\)/g, 
              (match, value, key) => `$storage.write(${value}, "${key}")`);
            
            // Convert $notify to $notification
            newContent = newContent.replace(/\$notify\s*\(\s*(.*?)\s*,\s*(.*?)\s*,\s*(.*?)(?:\s*,\s*(.*?))?\s*\)/g, 
              (match, title, subtitle, body, options) => {
                if (options) {
                  // Handle the options parameter if needed
                  return `$notification.post(${title}, ${subtitle}, ${body})`;
                } else {
                  return `$notification.post(${title}, ${subtitle}, ${body})`;
                }
              }
            );
            
            return newContent;
          }

          // Main function
          function main() {
            const args = process.argv.slice(2);
            const inputArg = args.indexOf('--input');
            const outputArg = args.indexOf('--output');
            const targetArg = args.indexOf('--target');
            
            if (inputArg === -1 || outputArg === -1 || targetArg === -1) {
              console.error('Usage: node convert.js --input <inputFile> --output <outputFile> --target <surge|loon>');
              process.exit(1);
            }
            
            const inputFile = args[inputArg + 1];
            const outputFile = args[outputArg + 1];
            const target = args[targetArg + 1];
            
            if (!inputFile || !outputFile || !target) {
              console.error('Usage: node convert.js --input <inputFile> --output <outputFile> --target <surge|loon>');
              process.exit(1);
            }
            
            try {
              const content = fs.readFileSync(inputFile, 'utf8');
              let convertedContent;
              
              if (target.toLowerCase() === 'surge') {
                convertedContent = convertToSurge(content);
              } else if (target.toLowerCase() === 'loon') {
                convertedContent = convertToLoon(content);
              } else {
                console.error(`Unsupported target: ${target}. Use 'surge' or 'loon'.`);
                process.exit(1);
              }
              
              // Ensure directory exists
              const dir = path.dirname(outputFile);
              if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
              }
              
              fs.writeFileSync(outputFile, convertedContent);
              console.log(`Successfully converted ${inputFile} to ${target} format at ${outputFile}`);
            } catch (error) {
              console.error(`Error: ${error.message}`);
              process.exit(1);
            }
          }

          main();
          EOF
          
      - name: Create output directories
        run: |
          mkdir -p Surge
          mkdir -p Loon
      
      - name: Convert QuantumultX scripts to Surge
        run: |
          for file in QuantumultX/*.js; do
            filename=$(basename "$file")
            echo "Converting $filename to Surge format..."
            node tools/convert.js --input "$file" --output "Surge/${filename}" --target surge
          done
      
      - name: Convert QuantumultX scripts to Loon
        run: |
          for file in QuantumultX/*.js; do
            filename=$(basename "$file")
            echo "Converting $filename to Loon format..."
            node tools/convert.js --input "$file" --output "Loon/${filename}" --target loon
          done
      
      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add Surge/ Loon/
          git commit -m "Auto convert scripts to Surge and Loon formats" || echo "No changes to commit"
          git push
