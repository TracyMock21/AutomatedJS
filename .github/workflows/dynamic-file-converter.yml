name: Dynamic File Converter

on:
  workflow_dispatch:
    inputs:
      filename:
        description: 'File name without extension (e.g., "adblock" for adblock.txt or adblock.js)'
        required: true
        type: string
      file_type:
        description: 'Optional: Force file type (rule, script, config). Default: auto-detect'
        required: false
        type: choice
        options:
          - auto
          - rule
          - script
          - config
        default: 'auto'

permissions:
  contents: write

jobs:
  convert-dynamic-file:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Debug repository structure
        run: |
          echo "Repository structure:"
          find . -type f | sort
          echo "--------------------"
          
      - name: Create output directories
        run: |
          mkdir -p Surge Loon
      
      - name: Find file with fuzzy matching
        id: find_file
        run: |
          FILENAME="${{ github.event.inputs.filename }}"
          echo "Looking for files matching: *${FILENAME}*"
          FILE_PATH=$(find . -type f -not -path "./Surge/*" -not -path "./Loon/*" -name "*${FILENAME}*" | sort -r | head -1)
          if [ -z "$FILE_PATH" ]; then
            echo "No exact match found, trying case-insensitive search..."
            FILE_PATH=$(find . -type f -not -path "./Surge/*" -not -path "./Loon/*" -iname "*${FILENAME}*" | sort -r | head -1)
          fi
          if [ -z "$FILE_PATH" ]; then
            echo "Could not find any file matching: ${FILENAME}"
            echo "Available files:"
            find . -type f
            exit 1
          fi
          echo "Found file: $FILE_PATH"
          echo "file_path=$FILE_PATH" >> $GITHUB_OUTPUT
      
      - name: Analyze file with Node.js
        run: |
          FILE_PATH="${{ steps.find_file.outputs.file_path }}"
          FILENAME=$(basename "$FILE_PATH" | sed 's/\.[^.]*$//')
          FILE_TYPE="${{ github.event.inputs.file_type }}"
          echo "Processing file: $FILE_PATH with basename: $FILENAME (Type: $FILE_TYPE)"
          
          cat > analyze.js << 'ANALYSIS_EOF'
          const fs = require('fs');
          const path = require('path');
          const filePath = process.argv[2];
          const fileTypeInput = process.argv[3] || 'auto';
          const filename = path.basename(filePath).replace(/\.[^.]*$/, '');
          const content = fs.readFileSync(filePath, 'utf8');
          const lines = content.split('\n').map(line => line.trim());
          let metadata = { name: filename, desc: 'Dynamic Module', author: 'Unknown', category: 'General', update: 'Unknown Date', channel: 'N/A', hostname: 'example.com' };
          let rules = [];
          let hostnames = new Set();
          let fileType = fileTypeInput;
          if (fileType === 'auto') {
            if (content.match(/script-(response|request)-body/) || (filePath.match(/\.js$/) && !content.match(/url\s+(reject|script-response-body)/))) {
              fileType = 'script';
            } else if (content.match(/url\s+(reject|script-response-body)/) || (content.match(/^(#|\/\/)/) && content.match(/\^https?:\/\//))) {
              fileType = 'rule';
            } else {
              fileType = 'config';
            }
          }
          console.error(`Detected file type: ${fileType}`);
          const addHostname = (line) => {
            const hostnameMatch = line.match(/(?:hostname\s*=|hostname\s*=)\s*([^#]+)/i);
            if (hostnameMatch) hostnameMatch[1].split(',').forEach(h => hostnames.add(h.trim()));
          };
          for (let line of lines) {
            if (!line) continue;
            if (line.match(/^(#|\/\/)/)) {
              if (line.match(/项目功能|功能|name/i)) metadata.name = line.replace(/.*(项目功能|功能|name)[:：=\s]*(.*)/i, '$2') || metadata.name;
              if (line.match(/使用声明|desc|description/i)) metadata.desc = line.replace(/.*(使用声明|desc|description)[:：=\s]*(.*)/i, '$2') || metadata.desc;
              if (line.match(/脚本作者|author/i)) metadata.author = line.replace(/.*(脚本作者|author)[:：=\s]*(.*)/i, '$2') || metadata.author;
              if (line.match(/更新日期|update|date/i)) metadata.update = line.replace(/.*(更新日期|update|date)[:：=\s]*(.*)/i, '$2') || metadata.update;
              if (line.match(/电报频道|channel|telegram/i)) metadata.channel = line.replace(/.*(电报频道|channel|telegram)[:：=\s]*(.*)/i, '$2') || metadata.channel;
              addHostname(line);
            } else if (line.match(/^\w+\s*=/)) {
              const [key, value] = line.split(/\s*=\s*/).map(s => s.trim().replace(/^["']|["']$/g, ''));
              if (['name', 'desc', 'author', 'category', 'update', 'channel', 'hostname'].includes(key.toLowerCase())) metadata[key.toLowerCase()] = value;
              addHostname(line);
            } else if (fileType === 'rule' && line.match(/^(http|\^https?:\/\/).*(url\s+(reject|script-response-body))/)) {
              rules.push(line);
            }
          }
          if (hostnames.size === 0) {
            if (fileType === 'rule' && rules.length > 0) {
              rules.forEach(rule => { const domainMatch = rule.match(/https?:\/\/([^\/]+)/); if (domainMatch) hostnames.add(domainMatch[1]); });
            } else if (fileType === 'script') {
              const domainMatch = content.match(/https?:\/\/([^\/]+)/);
              if (domainMatch) hostnames.add(domainMatch[1]);
            }
          }
          process.stdout.write(`NAME="${metadata.name}"\n`);
          process.stdout.write(`DESC="${metadata.desc}"\n`);
          process.stdout.write(`AUTHOR="${metadata.author}"\n`);
          process.stdout.write(`CATEGORY="${metadata.category}"\n`);
          process.stdout.write(`UPDATE="${metadata.update}"\n`);
          process.stdout.write(`CHANNEL="${metadata.channel}"\n`);
          process.stdout.write(`HOSTNAMES="${Array.from(hostnames).join(', ')}"\n`);
          process.stdout.write(`RULES="${rules.join('\n')}"\n`);
          process.stdout.write(`FILE_TYPE="${fileType}"\n`);
ANALYSIS_EOF
          
          node analyze.js "$FILE_PATH" "$FILE_TYPE" > extracted_data.txt
          echo "Contents of extracted_data.txt:"
          cat extracted_data.txt
          . ./extracted_data.txt
      
      - name: Generate Surge and Loon files
        run: |
          FILENAME=$(basename "${{ steps.find_file.outputs.file_path }}" | sed 's/\.[^.]*$//')
          FILE_TYPE="${{ github.event.inputs.file_type }}"
          . ./extracted_data.txt
          
          if [ "$FILE_TYPE" = "rule" ]; then
            cat > "Surge/${FILENAME}.sgmodule" << 'SURGE_EOF'
#!name = ${NAME}
#!desc = ${DESC} (Telegram: ${CHANNEL}, Updated: ${UPDATE})
#!author = ${AUTHOR}
#!category = ${CATEGORY}

${RULES}

[MITM]
hostname = %APPEND% ${HOSTNAMES}
SURGE_EOF
          else
            cat > "Surge/${FILENAME}.sgmodule" << 'SURGE_EOF'
#!name = ${NAME}
#!desc = ${DESC} (Telegram: ${CHANNEL}, Updated: ${UPDATE})
#!author = ${AUTHOR}
#!category = ${CATEGORY}

[Script]
${FILENAME} = type=http-response, pattern=^https?://${HOSTNAMES}/, script-path=https://raw.githubusercontent.com/user/repo/main/${FILENAME}.js, requires-body=true, max-size=-1, timeout=60

[MITM]
hostname = %APPEND% ${HOSTNAMES}
SURGE_EOF
          fi
          
          if [ "$FILE_TYPE" = "rule" ]; then
            cat > "Loon/${FILENAME}.plugin" << 'LOON_EOF'
#!name = ${NAME}
#!desc = ${DESC} (Telegram: ${CHANNEL}, Updated: ${UPDATE})
#!author = ${AUTHOR}
#!category = ${CATEGORY}

${RULES}

[MITM]
hostname = ${HOSTNAMES}
LOON_EOF
          else
            cat > "Loon/${FILENAME}.plugin" << 'LOON_EOF'
#!name = ${NAME}
#!desc = ${DESC} (Telegram: ${CHANNEL}, Updated: ${UPDATE})
#!author = ${AUTHOR}
#!category = ${CATEGORY}

[Script]
http-response ^https?://${HOSTNAMES}/ script-path=https://raw.githubusercontent.com/user/repo/main/${FILENAME}.js, requires-body=true, timeout=60, tag=${FILENAME}

[MITM]
hostname = ${HOSTNAMES}
LOON_EOF
          fi
          
          echo "Created Surge module: Surge/${FILENAME}.sgmodule"
          echo "Created Loon plugin: Loon/${FILENAME}.plugin"
      
      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add Surge/ Loon/
          git diff-index --quiet HEAD || git commit -m "Convert dynamic file: ${{ github.event.inputs.filename }}" || echo "No changes to commit"
          git push || echo "Nothing to push"
